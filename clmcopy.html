<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>3D调蓄池平台-全屏</title>
    <link rel="stylesheet" type="text/css" href="style001.css">
    <link rel="stylesheet" type="text/css" href="style003.css">


    <script src="AKK01.js"></script>
    <script src="AKK02.js"></script>
    <script src="AKK03.js"></script>
    <script src="AKK04.js"></script>
    <script src="AKK05.js"></script>
    <script src="AKK06.js"></script>
    <script src="AKK07.js"></script>
    <script src="AKK08.js"></script>
    <script src="AKK09.js"></script>
    <script src="AKK10.js"></script>
    <script src="AKK11.js"></script>
    <script src="AKK12.js"></script>
    <script src="AKK13.js"></script>
    <script src="AKK14.js"></script>
    <script src="AKK15.js"></script>
    <script src="AKK16.js"></script>
    <script src="AKK17.js"></script>
    <script src="draco_decoder.js"></script>
    <script src="all.min.js" defer></script>
    <script src="chart.js"></script>



    <style>
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        button.on {
            background-color: #4CAF50;
            color: rgb(38, 165, 238);
        }

        button.off {
            background-color: #f44336;
            color: rgb(16, 150, 212);
        }
    </style>


    <style>
        :root {
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --danger-color: #ea4335;
            --warning-color: #fbbc05;
            --light-gray: #f8f9fa;

        }



        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        h1 {
            color: var(--dark-gray);
            text-align: center;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .filter-section {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 6px;
        }

        .filter-section label {
            font-weight: 500;
            color: var(--dark-gray);
        }

        .filter-section input {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            font-size: 14px;
        }

        .filter-section input[type="password"] {
            width: 120px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        #refreshButton {
            background-color: var(--primary-color);
            color: white;
        }

        #downloadButton {
            background-color: var(--secondary-color);
            color: white;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        table {
            width: 100%;
            
            border-collapse: collapse;
            border-spacing: 0;

            box-shadow: 0 1px 3px rgba(72, 106, 255, 0.1);

            border-radius: 6px;
            
        }

        .table-container {
            
            max-height: 400px;
            /* 设置表格最大高度 */
            overflow: auto;
            /* 超出时显示滚动条 */
            margin-top: 18px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        thead {

             position: sticky;
    top: 0;
    z-index: 10;
    background: rgb(73, 164, 250);; /* 改为实色背景更清晰 */
    color: white;

        }
     

        th {
           
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            color: white;
           
            background: rgba(255, 255, 255, 0.1);
        }

        td {
          
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            background: rgba(255, 255, 255, 0.1);
        }



        .filter-input {
            width: 20%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 5px;
            background: rgba(255, 255, 255, 0.1);
        }

        .status-A {
            color: var(--secondary-color);
            font-weight: 500;
        }

        .status-R {
            color: var(--danger-color);
            font-weight: 500;
        }

        .status-1 {
            color: var(--warning-color);
            font-weight: 500;
        }

        .status-2 {
            color: var(--primary-color);
            font-weight: 500;
        }

        .status-3 {
            color: #6c757d;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            color: white;
        }

        .container3 {
            position: absolute;
            width: 820px;
            height: 60px;

            top: 10px;
        }

        .content {
            position: absolute;
            top: 5%;
            left: 5%;
            right: 5%;
            bottom: 5%;
            padding: 5%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        h1 {
            margin-bottom: 5%;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: textGlow 2s ease-in-out infinite alternate;
        }

        h2 {

            font-size: 20px;

            margin: 25px;
            padding: 10px;
            /* 调整间距 */


        }

        p {
            font-size: 1.2em;
            line-height: 1.6;
            max-width: 80%;
        }

        .glow-border {
            position: absolute;
            width: 100%;
            height: 100%;
        }


        @keyframes borderGlow {
            0% {
                filter: drop-shadow(0 0 8px rgba(8, 71, 131, 0.7));
            }

            50% {
                filter: drop-shadow(0 0 20px rgba(8, 71, 131, 0.9)) drop-shadow(0 0 30px rgba(8, 71, 131, 0.8));
            }

            100% {
                filter: drop-shadow(0 0 8px rgba(8, 71, 131, 0.7));
            }
        }

        @keyframes textGlow {
            0% {
                text-shadow: 0 0 5px rgba(8, 71, 131, 0.5);
            }

            50% {
                text-shadow: 0 0 15px rgba(8, 71, 131, 0.8), 0 0 25px rgba(8, 71, 131, 0.6);
            }

            100% {
                text-shadow: 0 0 5px rgba(8, 71, 131, 0.8);
            }
        }

        .border-path {
            animation: borderGlow 3s ease-in-out infinite alternate;
        }




        .chart-container {
            position: absolute;
            height: 120px;
            width: 120px;
            top: 38px;
            left: 30px;
            background-color: transparent;
            color: #ffffff;
            border: none;
            /* 移除边框 */
            outline: none;
            /* 可选：移除聚焦时的轮廓线（如果有） */


        }

        .chart-container2 {
            position: absolute;
            height: 120px;
            width: 185px;
            top: 38px;
            left: 150px;
            background-color: transparent;
            color: #ffffff;



        }

        .chart-container3 {
            position: absolute;
            height: 120px;
            width: 200px;
            top: 550px;
            left: 20px;






        }

        .chart-container4 {
            position: absolute;
            height: 120px;
            width: 200px;
            top: 550px;
            left: 220px;
            background-color: transparent;
            color: #ffffff;






        }

        .chart-container4 h2 {
            font-size: 15px;

            margin: 25px;
            padding: 5px;
            /* 调整间距 */
        }

        .chart-container2 h2 {
            font-size: 15px;

            margin: 25px;
            padding: 5px;
            /* 调整间距 */
        }



        #miniMap {
            position: absolute;
            top: 0px;
            right: 20px;
            width: 175px;
            height: 140px;

            border: 2px solid #ffffff;
            z-index: 100;
            background-image: url('map.png');
            background-size: cover;
            /* 可选：使图片覆盖整个div */
            background-position: center;
            /* 可选：居中图片 */
        }

        #cameraDot {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: rgb(255, 255, 255);
            border-radius: 50%;
            box-shadow: 0 0 10px rgb(255, 255, 255);
            transform: translate(-50%, -50%);
        }

        #directionArrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 20px solid rgb(255, 255, 255);
            transform-origin: center 10px;
            transform: translate(-50%, -50%);

        }





        #cameraInfo {
            position: absolute;
            width: 175px;
            height: 140px;

            left: 10px;
            background-color: transparent;
            padding: 5px;
            border-radius: 3px;
            color: #ffffff;
            line-height: 1.8;
            /* 新增：行高（默认1.2，1.5更宽松） */
        }

        #cameraInfo div {
            margin: 3px 0;
        }


        #overview1 {
            width: 1000px;
            padding: 0px;
            height: 700px;
            /* box-sizing: border-box;*/
            background-color: rgba(8, 71, 131, 0.2);
            ;
            line-height: 0px;
            position: absolute;
            /* 将位置设置为绝对定位 */
            top: 85px;
            /* 假设从页面顶部开始，向下10px */

            overflow: hidden;
            /* 隐藏溢出内容 */
            color: rgb(255, 255, 255);
            /* 更改文字颜色为白色 */
            border-radius: 4px;
            /* 为所有四个角添加10px的圆角 */

            transform: translateX(0);
            /* 初始位置 */
            animation: pulse2 1s infinite alternate;
            transition: transform 1s ease;
            /* 添加过渡动画 */
            /* 添加grid布局 */
            display: grid;
            grid-template-rows: repeat(5, 1fr);
            /* 5 行，每行高度均分 */
            grid-template-columns: 1fr;
            /* 1 列（默认） */

        }

        /* 添加关闭按钮样式 */
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* 默认情况下隐藏所有面板 */
        .panel {
            display: none;
        }



        /* 当某个面板成为target时显示它 */
        #overview:target,
        #devices:target,
        #analytics:target,
        #alerts:target,
        #settings:target {
            display: block;
        }

        /* 当某个面板成为target时，显示overview1容器 */
        #overview:target~#overview1,
        #devices:target~#overview1,
        #analytics:target~#overview1,
        #alerts:target~#overview1,
        #settings:target~#overview1 {
            display: grid;
        }

        /* 当某个面板成为target时，隐藏其他面板 */

        .overview1:has(#overview:target) .panel:not(#overview),

        .overview1:has(#devices:target) .panel:not(#devices),

        .overview1:has(#analytics:target) .panel:not(#analytics),

        .overview1:has(#alerts:target) .panel:not(#alerts),

        .overview1:has(#settings:target) .panel:not(#settings) {
            display: none;
        }



        .pump-container {
            display: flex;
            flex-wrap: wrap;
            position: absolute;
            top: 40px;
            gap: 8px;
            padding: 8px;
            background-color: rgba(0, 130, 252, 0.1);
            border-radius: 5px;
            max-width: 500px;
        }

        .pump-card {
            width: 55px;
            height: 100px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 6px;
            display: flex;
            flex-direction: column;
            background-color: rgba(0, 130, 252, 0);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            color: #ffffff;
        }

        .pump-icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .card-title {
            font-size: 10px;
            font-weight: bold;
            color: #ffffff;
            line-height: 1.8;
        }

        .status-indicator {
            width: 100%;
            height: 24px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            background-color: #e0e0e0;
            /* 初始灰色背景 */
        }

        .status-running {
            background-color: #4CAF50;
            color: white;
        }

        .status-stopped {
            background-color: #F44336;
            color: white;
        }

        .mode-indicator {
            width: 100%;
            height: 24px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            background-color: #e0e0e0;
            /* 初始灰色背景 */
            color: #ffffff;
        }

        .mode-manual {
            background-color: #FFC107;
            color: #ffffff;
        }

        .mode-auto {
            background-color: #2196F3;
            color: #fff;
        }










        .pump-container3 {
            display: flex;
            flex-wrap: wrap;
            position: absolute;
            top: 380px;
            gap: 8px;
            padding: 8px;
            background-color: rgba(0, 130, 252, 0.1);
            border-radius: 5px;
            max-width: 500px;
        }

        .pump-card3 {
            width: 55px;
            height: 100px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 6px;
            display: flex;
            flex-direction: column;
            background-color: rgba(0, 130, 252, 0);
        }

        .card-header3 {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            color: #ffffff;
        }

        .pump-icon3 {
            font-size: 14px;
            margin-right: 4px;
        }

        .card-title3 {
            font-size: 10px;
            font-weight: bold;
            color: #ffffff;
            line-height: 1.8;
        }

        .status-indicator3 {
            width: 100%;
            height: 24px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            background-color: #e0e0e0;
            /* 初始灰色背景 */
        }

        .status-running2 {
            background-color: #FFC107;
            color: white;
        }

        .status-running3 {
            background-color: #FFC107;
            color: white;
            animation: blink 1s infinite;
            /* 闪烁动画 */
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }

            100% {
                opacity: 1;
            }
        }

        .status-stopped3 {
            background-color: #F44336;
            color: white;
        }

        .mode-indicator3 {
            width: 100%;
            height: 24px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 4px;
            background-color: #e0e0e0;
            /* 初始灰色背景 */
            color: #ffffff;
        }

        .mode-manual3 {
            background-color: #FFC107;
            color: #ffffff;
        }

        .mode-auto3 {
            background-color: #2196F3;
            color: #fff;
        }
    </style>

    <!-- 超炫酷高科技球形菜单 HTML -->
    <div class="sidebar">
        <div class="menu-toggle">
            <i class="fas fa-atom"></i>
        </div>

        <ul class="nav-menu">
            <li><a href="#overview" data-tooltip="数据总览"><i class="fas fa-vr-cardboard"></i></a></li>
            <li><a href="#devices" data-tooltip="设备管理"><i class="fas fa-qubit"></i></a></li>
            <li><a href="#analytics" data-tooltip="数据分析"><i class="fas fa-brain"></i></a></li>
            <li><a href="#alerts" data-tooltip="故障报警"><i class="fas fa-shield-alt"></i></a></li>
            <li><a href="#settings" data-tooltip="系统设置"><i class="fas fa-cogs"></i></a></li>
        </ul>
    </div>
    <div class="container3">
        <svg class="glow-border" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 808 358" preserveAspectRatio="none">
            <defs>
                <!-- 主边框渐变 -->
                <linearGradient id="main-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#ffffff" />
                    <stop offset="50%" stop-color="#084783" />
                    <stop offset="100%" stop-color="#084783" />
                </linearGradient>

                <!-- 角线渐变 -->
                <linearGradient id="corner-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#ffffff" />
                    <stop offset="100%" stop-color="##084783" />
                </linearGradient>

                <style>
                    /* 主边框样式 */
                    .main-border {
                        fill: none;
                        stroke: url(#main-gradient);
                        stroke-width: 1;
                        stroke-dasharray: 100;
                        stroke-dashoffset: 100;
                        animation: dash 3s linear forwards infinite;
                    }

                    /* 角线样式 */
                    .corner-line {
                        fill: none;
                        stroke: url(#corner-gradient);
                        stroke-width: 1;
                        stroke-linecap: round;
                        stroke-dasharray: 100;
                        stroke-dashoffset: 100;
                        animation: dash 2s linear forwards infinite;
                    }
                </style>
                <filter id="glow" x="-40%" y="-40%" width="180%" height="180%">
                    <feGaussianBlur stdDeviation="1" result="blur" />
                    <feComposite in="SourceGraphic" in2="blur" operator="over" />
                </filter>
            </defs>

            <!-- 主边框 -->
            <path class="main-border border-path" d="M802,6V352H6V6H802m2-2H4V354H804V4Z" />

            <!-- 四个角线 -->
            <path class="corner-line border-path" d="M61,0l9,6H6V35L0,26V0Z" />
            <path class="corner-line border-path" d="M808,0V26l-6,9V6H738l9-6Z" />
            <path class="corner-line border-path" d="M0,358V332l6-9v29H70l-9,6Z" />
            <path class="corner-line border-path" d="M747,358l-9-6h64V323l6,9v26Z" />
        </svg>

        <div class="content">
            <h1>调蓄池数字孪生智慧平台</h1>

        </div>
    </div>





    <div id="overview1"><!--中间弹框 -->
        <!-- 三维总览面板 -->
        <div id="overview" class="panel">
            <span class="close-btn" onclick="hideOverview()">×</span>

            <h2>数据总览</h2>
            <div>
                <p>实时监控数据总览信息。</p>

            </div>
        </div>

        <!-- 设备管理面板 -->
        <div id="devices" class="panel">
            <span class="close-btn" onclick="hideOverview()">×</span>
            <h2>设备管理</h2>
            <div>
                <p>管理设备相关信息。</p>

            </div>
        </div>

        <!-- 数据分析面板 -->
        <div id="analytics" class="panel">
            <span class="close-btn" onclick="hideOverview()">×</span>
            <h2>数据分析</h2>
            <div>
                <p>数据分析及统计。</p>

            </div>
        </div>

        <!-- 故障报警面板 -->
        <div id="alerts" class="panel">
            <span class="close-btn" onclick="hideOverview()">×</span>
            <h2>故障报警</h2>
            <div>

                <h1>设备操作及报警记录</h1>

                <div class="filter-section">
                    <label for="inputA">起始日期:</label>
                    <input type="text" id="inputA" placeholder="例如：20240920">

                    <label for="inputB">结束日期:</label>
                    <input type="text" id="inputB" placeholder="例如：20240924">

                    <label for="inputC">设备号:</label>
                    <input type="text" id="inputC">

                    <input type="password" id="inputD">

                    <div class="button-group">
                        <button id="refreshButton">查询</button>
                        <button id="downloadButton">导出</button>
                    </div>
                </div>
                <div class="table-container">
                    <table id="data-table">
                        <thead>
                            <tr>
                                <th>序号</th>
                                <th>时间</th>
                                <th>类型</th>
                                <th>操作 <input type="text" placeholder="输入筛选" class="filter-input"
                                        onkeyup="filterTable(3)">
                                </th>
                                <th>内容</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- 数据将在这里动态插入 -->
                        </tbody>
                    </table>
                </div>
            </div>


        </div>

        <!-- 系统设置面板 -->
        <div id="settings" class="panel">
            <span class="close-btn" onclick="hideOverview()">×</span>
            <h2>系统设置</h2>
            <div>
                <p>配置系统参数，管理用户权限和系统偏好设置。</p>
            </div>
        </div>

    </div>


    <script>//菜单弹框显示
        // 监听 hash 变化
        window.addEventListener('hashchange', updateOverviewVisibility);

        // 页面加载时也检查一次
        window.addEventListener('DOMContentLoaded', updateOverviewVisibility);

        // 更新 #overview1 的显示状态
        function updateOverviewVisibility() {
            const overview1 = document.getElementById('overview1');
            if (!overview1) return;

            // 定义哪些 hash 会触发显示 #overview1
            const targetHashes = ['#overview', '#devices', '#analytics', '#alerts', '#settings'];
            const currentHash = window.location.hash;

            // 如果当前 hash 在目标列表中，显示 #overview1，否则隐藏
            if (targetHashes.includes(currentHash)) {
                overview1.style.display = 'grid';
            } else {
                overview1.style.display = 'none';
            }
        }

        // 如果需要手动隐藏（如点击关闭按钮）
        function hideOverview() {
            const overview1 = document.getElementById('overview1');
            if (overview1) {
                overview1.style.display = 'none';
            }
            // 清除 hash，防止重新触发显示
            history.pushState({}, document.title, window.location.pathname + window.location.search);
        }
    </script>



    <canvas id="renderCanvas">

    </canvas>


    <!-- 时间日期显示 -->
    <div class="scene-controls1" style=" position: absolute;
    top: 20px;
    right: 20px;  
    display: flex;
    gap: 10px;
    z-index: 10;
    color: white; 
    font-size: 18px;
     ">
        <div id="currentTime">00:00:00</div>
        <div id="currentDate">2023年10月22日 星期日</div>

    </div>




    <div class="scene-controls "><!--下边框按钮 -->
        <button class="control-btn pulse-glow" id="myButton"><i class="fas fa-eye-slash"></i>基础盖板</button>
        <button class="control-btn pulse-glow" id="myButton2"><i class="fas fa-eye-slash"></i>管理房</button>
        <button class="control-btn pulse-glow" id="myButton6"><i class="fas fa-eye-slash"></i>隐藏池体</button>
        <button class="control-btn pulse-glow" id="myButton3"><i class="fas fa-water"></i>水位</button>
        <button class="control-btn pulse-glow" id="myButton7"><i class="fas fa-tint"></i>冲洗水流</button>
        <button class="control-btn pulse-glow" id="myButton4"><i class="fas fa-sync-alt"></i>旋转视图</button>
        <button class="control-btn pulse-glow" id="myButton5"><i class="fas fa-layer-group"></i>喷射器视图</button>
        <button class="control-btn pulse-glow" id="myButton9"><i class="fas fa-layer-group"></i>冲洗门视图</button>
        <button class="control-btn pulse-glow" id="myButton10"><i class="fas fa-layer-group"></i>潜水泵视图</button>
        <button class="control-btn pulse-glow" id="myButton11"><i class="fas fa-layer-group"></i>格栅视图</button>
        <button class="control-btn pulse-glow" id="myButton12"><i class="fas fa-layer-group"></i>除臭视图</button>
        <button class="control-btn pulse-glow" id="myButton8"><i class="fas fa-layer-group"></i>地面视图</button>


    </div>
    <div id="box" style="right: 19.63px"><!--右边框显示 -->
        <div id="pump-container3" class="pump-container3">
            <!-- 水泵卡片将通过JavaScript动态添加到这里 -->
        </div>


        <div id="header1" style="top: 0px; ">调蓄池容量</div>
        <div class="chart-container">
            <!-- 画布用于绘制图表 -->
            <canvas id="myPieChart"></canvas>
        </div>
        <div class="chart-container2">
            <h2>剩余9000m³</h2>
            <h2>已用1000m³</h2>


        </div>
        <div id="header1" style="top: 170px; ">设备运行情况</div>
        <div class="chart-container4" style="top: 205px ; left:20px; ">
            <div id="ok2" style="line-height:25px;"></div>

        </div>


        <div id="header1" style="top: 340px; ">设备故障情况</div>
        <div id="header1" style="top: 510px; ">主要液位情况</div>
        <div class="chart-container3">
            <!-- 画布用于绘制图表 -->
            <canvas id="liquidLevelChart"></canvas>
        </div>
        <div class="chart-container4">
            <h2 id="ok4">雨水液位:1.8m</h2>
            <h2 id="ok3">污水液位:1.2m</h2>
            <h2>格栅液位:2.5m</h2>


        </div>
        <div id="header1" style="top: 680px; ">主要水质情况</div>
    </div>

    <div id="box1" style="left: 19.63px"><!--左边框显示 -->

        <div class="pump-container" id="pump-container"></div>



        <div id="header2" style="top: 0px; ">水泵运行数据</div>



        <div id="header2" style="top: 170px; ">格栅运行数据</div>
        <div id="header2" style="top: 340px; ">气体数据</div>
        <div id="header2" style="top: 510px; ">视频监控</div>

        <div id="miniMap" style="top: 710px;">
            <div id="cameraDot"></div>
            <div id="directionArrow"></div>


        </div>
        <div id="cameraInfo" style="top: 710px; ">
            <div>X: <span id="posX">0.00</span></div>
            <div>Y: <span id="posY">0.00</span></div>
            <div>Z: <span id="posZ">0.00</span></div>
            <div>角度: <span id="angleDeg">0.00°</span></div>
        </div>
        <div id="header2" style="top: 680px; ">地图坐标</div>
    </div>

    <script>// 更新日期
        function updateDateTime() {

            const now = new Date();
            // 更新时间
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('currentTime').textContent = `${hours}:${minutes}:${seconds}`;

            // 更新日期
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const weekday = weekdays[now.getDay()];
            document.getElementById('currentDate').textContent = `${year}年${month}月${day}日 ${weekday}`;
        }

        // 页面加载时立即更新时间
        updateDateTime();

        // 每秒更新一次时间
        setInterval(updateDateTime, 1000);
    </script>

    <script> // 菜单切换功能


        const box1 = document.getElementById('box1');


        // 菜单切换功能
        const menuToggle = document.querySelector('.menu-toggle');
        const sidebar = document.querySelector('.sidebar');

        menuToggle.addEventListener('click', function () {
            this.classList.toggle('active');
            sidebar.classList.toggle('active');



            // 根据菜单状态决定box的位置
            if (sidebar.classList.contains('active')) {
                box1.style.transform = 'translateX(240px)';
            } else {
                box1.style.transform = 'translateX(0)';
            }

            // 添加点击波纹效果
            const ripple = document.createElement('span');
            ripple.classList.add('ripple');
            this.appendChild(ripple);



            setTimeout(() => {
                ripple.remove();

            }, 1000);
        });

        // 鼠标离开菜单区域时自动收起
        sidebar.addEventListener('mouseleave', function () {
            if (this.classList.contains('active')) {
                setTimeout(() => {
                    this.classList.remove('active');
                    menuToggle.classList.remove('active');
                    box1.style.transform = 'translateX(0)';

                }, 200);
            }
        });



    </script>

    <style>
        /* 点击波纹效果 */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.7);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
        }

        @keyframes ripple {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>


    <script>
        // 添加边框绘制动画
        const paths = document.querySelectorAll('.main-border, .corner-line');
        paths.forEach(path => {
            const length = path.getTotalLength();
            path.style.strokeDasharray = length;
            path.style.strokeDashoffset = length;

            // 创建动画
            const animation = path.animate(
                [
                    { strokeDashoffset: length },
                    { strokeDashoffset: 0 }
                ],
                {
                    duration: path.classList.contains('corner-line') ? 2000 : 3000,
                    iterations: Infinity,
                    direction: 'alternate',
                    easing: 'ease-in-out'
                }
            );
        });

        // 添加CSS关键帧动画
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes dash {
                to {
                    stroke-dashoffset: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>




    <script> // 全局图表-饼图
        const data = {
            datasets: [{
                data: [90, 10], // 数据值
                backgroundColor: [ // 对应的颜色
                    'rgb(139, 255, 255,0.6)', // 白色不透明
                    'rgb(0, 0, 0,0)' // 完全透明
                ],
                borderWidth: 1, // 边框宽度
                borderColor: 'rgba(139, 255, 255,0.3)', // 边框半透明
                hoverOffset: 4 // 鼠标悬停时元素的偏移量
            }]
        };

        const config = {
            type: 'pie', // 饼图
            data: data,
            options: {
                responsive: true, // 响应式

                layout: {
                    padding: {
                        left: 5, // 左内边距
                        right: 5, // 右内边距
                        top: 5, // 上内边距
                        bottom: 5 // 下内边距
                    }
                },
                plugins: {
                    legend: {
                        display: false // 隐藏图例
                    },
                    title: {
                        display: false // 隐藏标题
                    }
                }
            }
        };

        const ctx = document.getElementById('myPieChart').getContext('2d');
        const myPieChart = new Chart(ctx, config);
    </script>



    <script src="./ycdl.js">// 用于获取网关秘钥</script>
    <script>// 用于获取数据

        var ok
        var ok23
        var ok24
        var ok25
        var shb1
        var shb2
        var shb3
        var shb4
        var shb5
        var shb6
        window.isDataReady = false; // 初始化状态

        const abc = 53405010139;
        const def = `123`;

        // 获取 SID 从 localStorage
        function getSidFromLocalStorage() {
            return localStorage.getItem(abc) || null;
        }
        async function fetchSecond(sid) {
            const myHeaders = new Headers();
            const url = `http://47.114.53.27:7080/exdata?SID=${sid}&OP=R`;
            //const raw = "15\r\nv15_63\r\nv22_42\r\nv23_42\r\nv24_42\r\nv50_22\r\nv53_22\r\nv19_42\r\nv20_42\r\nv21_42\r\nv19_46\r\nv20_46\r\nv21_46\r\nv22_46\r\nv23_46\r\nv24_46";
            const raw = `21
v15_63
v22_42
v23_42
v24_42
v50_22
v53_22
v19_42
v20_42
v21_42
v19_46
v20_46
v21_46
v22_46
v23_46
v24_46
v19_43
v20_43
v21_43
v22_43
v23_43
v24_43
`;
            const requestOptions = {
                method: "POST",
                headers: myHeaders,
                body: raw,
                redirect: "follow"
            };
            try {
                const response = await fetch(url, requestOptions);
                if (!response.ok) {
                    throw new Error('Second network response was not ok');
                }
                const result = await response.text();
                //console.log(result); // 在控制台输出数据
                // 将结果按行分割
                const lines = result.split(/\r?\n/);
                localStorage.setItem("jk", result);
                const jk1 = localStorage.getItem("jk");
                ok = jk1.split(/\r?\n/);
                // console.log(ok[2]);



                const ok22 = document.getElementById("ok2");
                ok22.textContent = "进水闸门开度: " + parseFloat(ok[2]).toFixed(2) + " mm";
                ok23 = document.getElementById("ok3");
                ok23.textContent = "污水液位: " + parseFloat(ok[6]).toFixed(2) + " m";
                ok24 = document.getElementById("ok4");
                ok24.textContent = "雨水液位: " + parseFloat(ok[7]).toFixed(2) + " m";







                if ((ok[0] == "ERROR") && (ok[1] == 8)) {
                    ycdl(abc, devicePassword)
                }
                localStorage.setItem("jk1", ok[2]);
                localStorage.setItem(lines);













            } catch (error) {

            }
            window.isDataReady = true; // 标记数据已准备好

        }

        setInterval(() => fetchSecond(getSidFromLocalStorage()), 1000); // 每秒刷新一次




        // 导出 fetchSecond 函数供外部调用
        window.fetchSecond = fetchSecond;
        window.ok = ok;

    </script>




    <script> // 水泵状态显示

        // 独立信号变量
        const pumpSignals = {
            // 模式信号 (0=手动, 1=自动)
            mode: ['0', '0', '0', '0', '1', '0'],
            // 状态信号 (0=停止, 1=运行)
            status: ['0', '0', '0', '0', '0', '0']
        };

        // 外部变量映射到水泵状态
        function updatePumpStatusFromExternalVars() {


            // 更新状态数组 (假设外部变量1=运行，0=停止)
            pumpSignals.status[0] = ok[8];
            //pumpSignals.status[0] = (parseFloat(ok[6]) > 1) ? '1' : ok[6];
            pumpSignals.status[1] = ok[9];
            pumpSignals.status[2] = ok[10];
            pumpSignals.status[3] = ok[3];
            pumpSignals.status[4] = ok[4];
            pumpSignals.status[5] = ok[5];
            // pumpSignals.status[5] = (parseFloat(ok[7]) > 1) ? '1' : ok[7];
            // console.log(ok[8]);
            pumpSignals.mode[0] = ok[11];
            //pumpSignals.status[0] = (parseFloat(ok[6]) > 1) ? '1' : ok[6];
            pumpSignals.mode[1] = ok[12];
            pumpSignals.mode[2] = ok[13];
            pumpSignals.mode[3] = ok[14];
            pumpSignals.mode[4] = ok[15];
            pumpSignals.mode[5] = ok[16];
            // 更新UI
            updateAllPumpStatuses();
        }

        /**
         * 初始化水泵卡片
         */
        function initPumpCards() {
            const container = document.getElementById('pump-container');

            for (let i = 1; i <= 6; i++) {
                const card = document.createElement('div');
                card.className = 'pump-card';
                card.id = `pump-card-${i}`;

                card.innerHTML = `
                <div class="card-header">
                    <i class="fas fa-tint pump-icon"></i>
                    <div class="card-title">水泵 #${i}</div>
                </div>
                <div class="mode-indicator" id="pump${i}-mode">
                    ${pumpSignals.mode[i - 1] === '1' ? '自动' : '手动'}
                </div>
                <div class="status-indicator" id="pump${i}-status">
                    ${pumpSignals.status[i - 1] === '1' ? '运行' : '停止'}
                </div>
            `;

                container.appendChild(card);
            }
        }

        /**
         * 更新单个水泵显示状态
         * @param {number} pumpId - 水泵ID (1-6)
         */
        function updateSinglePumpStatus(pumpId) {
            // 更新模式显示
            const mode = pumpSignals.mode[pumpId - 1];
            const modeElement = document.getElementById(`pump${pumpId}-mode`);

            if (mode === '1') {
                modeElement.textContent = '自动';
                modeElement.className = 'mode-indicator mode-auto';
            } else {
                modeElement.textContent = '手动';
                modeElement.className = 'mode-indicator mode-manual';
            }

            // 更新运行状态显示
            const status = pumpSignals.status[pumpId - 1];
            const statusElement = document.getElementById(`pump${pumpId}-status`);

            if (status === '1') {
                statusElement.textContent = '运行';
                statusElement.className = 'status-indicator status-running';
            } else {
                statusElement.textContent = '停止';
                statusElement.className = 'status-indicator status-stopped';
            }
        }

        /**
         * 更新所有水泵状态
         */
        function updateAllPumpStatuses() {
            for (let i = 1; i <= 6; i++) {
                updateSinglePumpStatus(i);
            }
        }

        // 页面加载完成后初始化
        window.onload = function () {
            // 创建水泵卡片
            initPumpCards();

            // 初始状态更新
            updateAllPumpStatuses();



            // 设置定时器实时更新状态
            setInterval(updatePumpStatusFromExternalVars, 1000); // 每1秒更新一次
        };
    </script>



    <script> // 全局图表-液位

        let liquidLevelChart;

        // 初始化数据配置
        const data2 = {
            labels: ['雨水泵', '污水泵', '格栅室'],
            datasets: [{
                data: [0, 0, 0], // 初始值
                backgroundColor: 'rgba(139, 255, 255, 0.6)',
                borderColor: 'rgba(139, 255, 255, 1)',
                borderWidth: 1
            }]
        };

        const config2 = {
            type: 'bar',
            data: data2,
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.parsed.y} m` // 提示框显示单位
                        },
                        bodyColor: 'white',
                        titleColor: 'white'
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: 'white',
                            callback: function (value) {
                                return value + ' m'; // Y轴刻度加单位
                            }
                        },
                        title: {
                            display: true,
                            text: '液位高度 (m)', // Y轴标题单位
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 1)'
                        }
                    },
                    x: {
                        ticks: {
                            color: 'white'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 1)'
                        }
                    }
                },
                elements: {
                    bar: {
                        barPercentage: 0.2,
                        categoryPercentage: 0.2
                    }
                }
            }
        };

        // 初始化图表
        function initChart() {
            const ctx2 = document.getElementById('liquidLevelChart').getContext('2d');
            liquidLevelChart = new Chart(ctx2, config2);
        }

        // 更新图表数据
        function updateChartData(newData) {
            liquidLevelChart.data.datasets[0].data = newData;
            liquidLevelChart.update();
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            initChart();

            // 模拟实时数据（实际替换为你的数据源）
            setInterval(() => {

                //updateChartData([window.ok[7], window.ok[6], 2.5]);
                const value1 = window.ok?.[7] ?? 0; // 使用可选链 ?. 和空值合并 ??
                const value2 = window.ok?.[6] ?? 0;
                updateChartData([value1, value2, ok25]);
            }, 1000);
        });
    </script>



    <script>// 用于获取模型







        if (1) {
            // 修改移动设备的样式
            //document.getElementById('info').style.width = '40%';
            //document.getElementById('info').style.position = 'absolute';
            //.getElementById('info').style.backgroundColor = 'transparent';
            //document.getElementById('info').style.overflow = 'hidden';
            //document.getElementById('info').style.color = 'white';
            document.getElementById('renderCanvas').style.width = '100%';// 设置画布宽度为100%
        }
        var canvas = document.getElementById("renderCanvas");// 获取画布
        var engine = new BABYLON.Engine(canvas, true);// 创建引擎
        engine.antialias = true,  // 启用基础抗锯齿
            engine.stencil = true,    // 启用模板缓冲(提升质量)
            engine.preserveDrawingBuffer = false, // 关闭可提高性能
            engine.powerPreference = "high-performance" // 高性能模式
        var createScene = function () {



            var scene = new BABYLON.Scene(engine);// 创建场景
            scene.collisionsEnabled = true;// 启用碰撞检测
            var camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2, 80, new BABYLON.Vector3(0, 0, 0), scene);// 创建相机

            camera.attachControl(canvas, true);// 将相机绑定到画布
            camera.inertia = 0.5// 设置相机惯性
            camera.minZ = 1.6// 设置相机最小Z值
            camera.maxZ = 1600// 设置相机最大Z值
            camera.fov = 0.8// 设置相机视野
            camera.mode = 0// 设置相机模式
            camera.lowerRadiusLimit = 55// 设置相机最小半径限制
            camera.upperRadiusLimit = 80// 设置相机最大半径限制
            camera.angularSensibilityX = 2000   // 设置相机X轴角度灵敏度    
            camera.angularSensibilityY = 2000   // 设置相机Y轴角度灵敏度
            camera.pinchDeltaPercentage = 0.005 // 设置相机缩放灵敏度
            camera.wheelDeltaPercentage = 0.005 // 设置相机滚轮缩放灵敏度
            camera.speed = 0.05 // 设置相机移动速度
            camera.useAutoRotationBehavior = 0  // 设置相机自动旋转行为


            var camera1 = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, -1, 0), scene);  // 创建自由相机
            camera1.attachControl(canvas, true) // 将相机绑定到画布
            camera1.applyGravity = true; // 启用相机重力
            camera1.gravity = new BABYLON.Vector3(0, -1, 0); // 重力速度加倍（-1 m/s²）

            camera1.checkCollisions = true; // 启用相机碰撞检测
            camera1.ellipsoid = new BABYLON.Vector3(0.05, 1.8, 0.05); // 宽0.5，高1.8，深0.5（类似人形角色）

            //camera1.collisionMask = -0.1; // 与所有碰撞体碰撞
            //camera1.ellipsoidOffset = new BABYLON.Vector3(0, 1.5, 0); // 偏移Y轴，使底部对齐地面
            // 设置相机移动参数（避免速度过快导致穿模）
            camera1.speed = 0.5;  // 移动速度
            camera1.angularSensibility = 3000; // 鼠标灵敏度
            camera1.minZ = 0.1;   // 近裁剪面（避免穿模时视角异常）
            // 跳跃功能变量






            // 动态更新偏移量
            scene.registerBeforeRender(() => {
                const ray = new BABYLON.Ray(
                    camera1.position,
                    new BABYLON.Vector3(0, -1, 0),
                    camera1.ellipsoid.y
                );
                const hit = scene.pickWithRay(ray);

                if (hit.pickedMesh?.checkCollisions) {
                    const targetOffset = camera1.position.y - hit.pickedPoint.y;
                    camera1.ellipsoidOffset.y = Math.max(targetOffset, 0.1);
                }
            });




















            var isJumping = false;
            var jumpHeight = 2;          // 跳跃高度
            var jumpDuration = 100;       // 跳跃持续时间（帧数）
            var jumpFrame = 0;
            var jumpStartY = 0;          // 跳跃起始Y坐标
            var currentJumpProgress = 0; // 当前跳跃进度（0-1）
            camera1.speed = 0.1;
            camera1.keysUp.push(87);     // W
            camera1.keysLeft.push(65);   // A
            camera1.keysDown.push(83);   // S
            camera1.keysRight.push(68);  // D
            scene.onKeyboardObservable.add((kbInfo) => {
                if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
                    if (kbInfo.event.code === "Space" && !isJumping) {
                        startJump();
                    }
                }
            });
            function startJump() {
                if (isJumping) return;

                isJumping = true;
                jumpFrame = 0;
                jumpStartY = camera1.position.y;
                currentJumpProgress = 0;

                // 暂时禁用重力，避免跳跃时被拉回地面
                camera1.applyGravity = false;
            }

            function updateJump() {
                if (!isJumping) return;

                jumpFrame++;
                currentJumpProgress = jumpFrame / jumpDuration;

                // 使用正弦函数计算跳跃高度（更平滑的抛物线）
                var jumpOffset = Math.sin(currentJumpProgress * Math.PI) * jumpHeight;

                // 更新相机Y坐标（不影响XZ移动）
                camera1.position.y = jumpStartY + jumpOffset;

                // 跳跃结束时恢复重力
                if (jumpFrame >= jumpDuration) {
                    endJump();
                }
            }

            function endJump() {
                isJumping = false;
                camera1.applyGravity = true;
            }
            scene.registerBeforeRender(function () {
                updateJump();
            });

















            camera1.attachControl() // 将相机绑定到画布

            scene.activeCamera = camera1//场景相机切换
            const env = scene.createDefaultEnvironment(); // 创建默认环境   
            env.skybox.dispose();   // 删除默认天空盒
            scene.clearColor = new BABYLON.Color3(0.031, 0.15, 0.40);// 设置场景背景颜色



            //scene.createDefaultCameraOrLight(true, true, true);//默认光源
            camera.frustumCulling = true    //相机视锥剔除
            camera1.frustumCulling = true    //相机视锥剔除















































            BABYLON.SceneLoader.ImportMesh(
                "",
                "clm2/",
                "txcv21.draco.gltf",
                scene,
                function (meshes) {

                    var transformNodes = []; // 存储所有TransformNode




                    // 存储所有网格对象
                    allMeshes = meshes.filter(mesh => mesh instanceof BABYLON.Mesh);

                    // 为所有模型启用碰撞检测
                    allMeshes.forEach(mesh => {
                        mesh.checkCollisions = true;
                        //mesh.ellipsoid = new BABYLON.Vector3(1, 1, 1); // 根据模型尺寸调整
                    });

















                    // 遍历场景中的所有网格对象
                    meshes.forEach((node) => {
                        const { parent, name: nodeName, position, rotation, scaling } = node;        // 获取网格的父节点、名称、位置、旋转和缩放
                        const parentNode = parent?.name || "无";            // 获取父节点的名称，如果没有父节点，则名称为"无"

                        // 调试信息对象
                        const debugInfo = {
                            nodeName,
                            parentNode,
                            position: position.asArray(),
                            rotation: rotation.asArray(),
                            scaling: scaling.asArray()
                        };           // 将调试信息对象添加到调试信息数组中



                        // 获取所有网格（Mesh）和变换节点（TransformNode）
                        const meshes = scene.meshes;
                        const transformNodes = scene.transformNodes;

                        const allNodes = [...meshes, ...transformNodes];  // 合并两类节点

                        // 遍历所有网格和变换节点
                        allNodes.forEach((node, index) => {  // 添加 index 参数
                            const { parent, name: nodeName } = node;
                            const parentNode = parent?.name || "无";

                            // 仅当节点类型支持时才获取变换属性
                            const position = node.position ? node.position.asArray() : [0, 0, 0];
                            const rotation = node.rotation ? node.rotation.asArray() : [0, 0, 0];
                            const scaling = node.scaling ? node.scaling.asArray() : [1, 1, 1];

                            // 调试信息对象
                            const debugInfo = {
                                nodeName,
                                parentNode,
                                position,
                                rotation,
                                scaling
                            };

                            // 判断根节点（无父节点或父节点是场景本身）
                            const isRoot = !parent || parent === scene;

                            // 添加数组索引号 [index] 到日志输出
                            //console.log(`[${index}] ${node.name} [${node.getClassName()}] ${isRoot ? "(根节点)" : ""} 父节点: ${parentNode}`);

                        });
                        var PSQ = scene.getNodeByName("喷射器管-1");


                        let currentRotationY = 0;
                        let directionY = 1;

                        scene.registerBeforeRender(() => {
                            // 将当前旋转（度）转换为弧度  
                            let rotationRadians = currentRotationY * Math.PI / 180;
                            //allNodes[188]
                            PSQ.rotation = new BABYLON.Vector3(0, rotationRadians, 0)
                            currentRotationY += directionY * 0.2; // 每帧增加 0.1 度

                            if (currentRotationY > 240) {
                                directionY = -1;
                            }
                            if (currentRotationY < -60) {
                                directionY = 1;
                            }



                        });
                        var beng1 = scene.getMeshByName("color[1]");
                        var beng2 = scene.getMeshByName("color[2]");
                        var beng3 = scene.getMeshByName("light concrete 2d-2");
                        var beng4 = scene.getMeshByName("heavy ripple water");
                        var beng5 = scene.getMeshByName("芳草溪调蓄池基础1");


                        beng1.material.albedoColor = new BABYLON.Color3(0, 1, 0);
                        beng2.material.albedoColor = new BABYLON.Color3(1, 0, 0);


                        //var glf1 = scene.getMeshByName("color-7"); //获取到模型
                        //glf1.checkCollisions = true;
                        var SW = scene.getNodeByName("水位-1");
                        SW.position = new BABYLON.Vector3(0, 0, 0); //设置初始位置



                        setInterval(function () {
                            SW.scaling = new BABYLON.Vector3(1, (1 / 4.1) * ok[6], 1);
                            SW.position = new BABYLON.Vector3(0, (0.5 * ok[6]) - 6.5, 0);
                        }, 1000); // 1000毫秒 = 1秒 0.5*ok[7] (0.5*ok[7])-6.8






















                        //移动函数
                        async function yd(currentYPosition, direction, name3) {
                            currentYPosition = 0; // 初始 Y 坐标偏移量  
                            direction = 1; // 控制Y坐标偏移量的方向，1为向上，-1为向下 
                            // 根据条件执行不同的变换
                            var yd01 = scene.getMeshByName(name3)



                            scene.registerBeforeRender(() => {
                                // 更新 Y 坐标偏移量  
                                currentYPosition += direction * 0.003;

                                // 当currentYPosition达到或超过2时，改变方向向下  
                                if (currentYPosition >= 1.8) {
                                    direction = -1;
                                }
                                // 当currentYPosition减小到0或以下时，改变方向向上  
                                if (currentYPosition <= 0) {
                                    direction = 1;
                                }
                                yd01.position.y = currentYPosition




                            });


                        }



                        let a1
                        let a2
                        let a3
                        let a4
                        let a5
                        let a6
                        let a7
                        let a8
                        let a9
                        let a10
                        let a11
                        let a12


                        yd(a1, a2, "satin finish stainless steel-27")
                        yd(a3, a4, "satin finish stainless steel-27[1]")
                        yd(a5, a6, "satin finish stainless steel-27[2]")
                        yd(a7, a8, "satin finish stainless steel-27[3]")
                        yd(a9, a10, "satin finish stainless steel-27[4]")
                        yd(a11, a12, "satin finish stainless steel-27[5]")










                        // 隐藏模型
                        async function yingchangjd(fjd, yingchang) {
                            if (parentNode === fjd) {
                                node.getChildMeshes().forEach(child => child.isVisible = yingchang);
                                node.isVisible = yingchang;
                            }
                        }


                        yingchangjd("地面盖板", 0)   //隐藏调蓄池总装

                        yingchangjd("水位", 0) //隐藏水位






                        let clickCount = 0
                        let clickCount1 = 0
                        let clickCount2 = 0
                        let clickCount3 = 0
                        let clickCount4 = 0


                        document.getElementById("myButton").addEventListener("click", function () {
                            clickCount++;

                            if (clickCount === 2) {
                                yingchangjd("基础盖板-2", 1);
                                yingchangjd("零件9^调蓄池总装-1", 1);

                                clickCount = 0; // 重置计数器，以便下次第二次点击再次触发
                            } else {
                                yingchangjd("基础盖板-2", 0);
                                yingchangjd("零件9^调蓄池总装-1", 0);

                            }

                        });
                        document.getElementById("myButton2").addEventListener("click", function () {
                            clickCount1++;

                            if (clickCount1 === 2) {
                                yingchangjd("管理房-1", 1);
                                clickCount1 = 0; // 重置计数器，以便下次第二次点击再次触发
                            } else {
                                yingchangjd("管理房-1", 0);
                            }

                        });
                        document.getElementById("myButton3").addEventListener("click", function () {
                            clickCount2++;

                            if (clickCount2 === 2) {
                                yingchangjd("水位-1", 1);
                                clickCount2 = 0; // 重置计数器，以便下次第二次点击再次触发
                            } else {
                                yingchangjd("水位-1", 0);
                            }

                        });
                        document.getElementById("myButton6").addEventListener("click", function () {
                            clickCount1++;

                            if (clickCount1 === 2) {
                                yingchangjd("芳草溪调蓄池基础-1", 1);
                                clickCount1 = 0; // 重置计数器，以便下次第二次点击再次触发
                            } else {
                                yingchangjd("芳草溪调蓄池基础-1", 0);
                            }

                        });


                        document.getElementById("myButton7").addEventListener("click", function () {
                            clickCount4++;

                            if (clickCount4 === 2) {
                                waterEffect.particleSystem.start();
                                waterEffect.particleSystem.emitter.x = 30
                                clickCount4 = 0; // 重置计数器，以便下次第二次点击再次触发
                            } else {
                                waterEffect.particleSystem.stop();
                                waterEffect.particleSystem.emitter.x = 30
                            }

                        });




                        var parentNode1 = scene.getMeshByName("球1");

                        // 创建粒子系统（限制 500 粒子）
                        const particleSystem = new BABYLON.ParticleSystem("particles", 5000, scene);



                        // 球形发射区域（半径 0.1）

                        var pointEmitter = particleSystem.createPointEmitter(new BABYLON.Vector3(), new BABYLON.Vector3());
                        particleSystem.emitter = parentNode1;//粒子发射器
                        particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD; // 代码值 1


                        // 纹理设置（需准备 particle.png）







                        particleSystem.particleTexture = new BABYLON.Texture("textures/particle.png", scene);//粒子纹理
                        particleSystem.textureMask = new BABYLON.Color4(0, 0.01, 0.01, 0.1); // 强制颜色覆盖纹理
                        particleSystem.color1 = new BABYLON.Color4(0, 1, 1, 1);    // 起始颜色
                        particleSystem.color2 = new BABYLON.Color4(0, 0.8, 0.8, 0.3); // 结束颜色（稍暗且半透明）
                        particleSystem.colorDead = new BABYLON.Color4(0, 0.5, 0.5, 0.1); // 消失时微弱可见



                        particleSystem.isBillboardBased = true;//粒子始终朝向摄像机



                        // 尺寸与生命周期
                        particleSystem.minSize = 0.01;
                        particleSystem.maxSize = 0.1;
                        particleSystem.minLifeTime = 10;
                        particleSystem.maxLifeTime = 10;

                        // 运动参数
                        particleSystem.emitRate = 100;//每秒发射粒子数
                        particleSystem.direction1 = new BABYLON.Vector3(-1, 0.08, 0.08);//粒子运动方向1
                        particleSystem.direction2 = new BABYLON.Vector3(-1, -0.08, -0.08);//粒子运动方向2
                        particleSystem.gravity = new BABYLON.Vector3(0, 0, 0); // 重力

                        particleSystem.updateSpeed = 0.025 // 更新速度





                        // 启动系统
                        particleSystem.start();











                    });





                }


            );






            // 创建水流效果
            const createWaterEffect = (kkk) => {
                // 粒子系统 - 水流飞溅
                const particleSystem = new BABYLON.ParticleSystem("particles", 20000, scene);
                particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD; // 代码值 0
                particleSystem.particleTexture = new BABYLON.Texture("textures/particle.png", scene);
                particleSystem.textureMask = new BABYLON.Color4(0, 0.1, 0.1, 0.1); // 强制颜色覆盖纹理
                particleSystem.emitter = new BABYLON.Vector3(-5, -2.6, -11);//发射器位置
                particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, -2.5);//发射器最小范围
                particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 2.5);//发射器最大范围

                particleSystem.color1 = new BABYLON.Color4(0, 1, 1, 1);    // 起始颜色
                particleSystem.color2 = new BABYLON.Color4(0, 0.8, 0.8, 0.3); // 结束颜色（稍暗且半透明）
                particleSystem.colorDead = new BABYLON.Color4(0, 0.5, 0.5, 0.1); // 消失时微弱可见




                particleSystem.minSize = 0.2;
                particleSystem.maxSize = 0.5;

                particleSystem.minLifeTime = 1;
                particleSystem.maxLifeTime = 2;

                particleSystem.emitRate = 8000;

                particleSystem.direction1 = new BABYLON.Vector3(0, 0, 0);//粒子发射方向1
                particleSystem.direction2 = new BABYLON.Vector3(0, 0, 0);//粒子发射方向2

                particleSystem.minEmitPower = 0.1;
                particleSystem.maxEmitPower = 0.3;
                particleSystem.updateSpeed = 0.03;

                particleSystem.gravity = new BABYLON.Vector3(0, -0.2, 0);//

                particleSystem.start();



                if (kkk === 1) {
                    const fluidRenderer = scene.enableFluidRenderer();
                    const renderObject = fluidRenderer.addParticleSystem(particleSystem);

                    const fluidObject = renderObject.object;
                    const targetRenderer = renderObject.targetRenderer;
                    targetRenderer.density = 0.15;// 密度
                    targetRenderer.fresnelClamp = 0.001;// 反射
                    targetRenderer.refractionStrength = 0.001;// 折射
                }


                return { particleSystem };
            };
            let waterEffect = createWaterEffect(0)


            // 创建场景
            document.getElementById("myButton4").addEventListener("click", function () {
                scene.activeCamera = camera//场景相机切换
                //waterEffect = createWaterEffect(0) 


            });
            document.getElementById("myButton5").addEventListener("click", function () {
                scene.activeCamera = camera1//场景相机切换
                camera1.position = new BABYLON.Vector3(-14.14, -0.62, -11.51); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    0,  // 俯仰角（X轴，上下点头）
                    -141.71 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });
            document.getElementById("myButton8").addEventListener("click", function () {

                camera1.position = new BABYLON.Vector3(-14.14, 10, -11.51); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    0,  // 俯仰角（X轴，上下点头）
                    -141.71 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });

            document.getElementById("myButton9").addEventListener("click", function () {

                camera1.position = new BABYLON.Vector3(-36.75, -0.72, -11.2); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    0,  // 俯仰角（X轴，上下点头）
                    -268.82 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });



            document.getElementById("myButton10").addEventListener("click", function () {

                camera1.position = new BABYLON.Vector3(-30.94, -0.62, -28.63); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    35 * Math.PI / 180,  // 俯仰角（X轴，上下点头）
                    -89.96 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });

            document.getElementById("myButton11").addEventListener("click", function () {

                camera1.position = new BABYLON.Vector3(-32, 10, 12.5); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    0,  // 俯仰角（X轴，上下点头）
                    -90 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });
            document.getElementById("myButton12").addEventListener("click", function () {

                camera1.position = new BABYLON.Vector3(-33, 10, -12.51); // 移动到新位置
                // 设置相机旋转角度（弧度制）
                camera1.rotation = new BABYLON.Vector3(
                    0,  // 俯仰角（X轴，上下点头）
                    -90 * Math.PI / 180,    // 偏航角（Y轴，左右转头）
                    0    // 翻滚角（Z轴，极少用）
                );
                // waterEffect = createWaterEffect(1) 

            });







            // 动画 - 水流移动
            scene.registerBeforeRender(() => {
                // 粒子系统移动
                waterEffect.particleSystem.emitter.x -= 0.25;
                if (waterEffect.particleSystem.emitter.x < -34) {
                    waterEffect.particleSystem.emitter.x = 30;
                }
            });









            // 创建管道网格
            function createPipe(position, rotation, length, diameter) {
                // 创建圆柱体作为管道
                const pipe = BABYLON.MeshBuilder.CreateCylinder('pipe', {
                    diameter: diameter,
                    height: length,
                    tessellation: 16,
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, scene);

                pipe.position = position;
                pipe.rotation = rotation;
                pipe.rotationQuaternion = null;

                // 创建水流材质
                const waterMaterial = new BABYLON.StandardMaterial('waterMat', scene);
                waterMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0);
                waterMaterial.alpha = 0.5;
                waterMaterial.specularPower = 100;

                // 创建水流纹理 - 使用程序生成的渐变纹理
                const waterTexture = new BABYLON.DynamicTexture('waterTex', 512, scene, true);
                const ctx = waterTexture.getContext();

                // 创建从透明到绿色再到透明的渐变
                const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(0.1, 'rgba(0,0,0,0)');
                gradient.addColorStop(0.15, 'rgba(50,255,0,0.7)');  // 改为绿色
                gradient.addColorStop(0.3, 'rgba(100,255,0,0.9)');  // 改为绿色
                gradient.addColorStop(0.7, 'rgba(100,255,0,0.9)');  // 改为绿色
                gradient.addColorStop(0.85, 'rgba(50,255,0,0.7)');  // 改为绿色
                gradient.addColorStop(0.9, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);

                waterTexture.update();
                waterMaterial.diffuseTexture = waterTexture;
                waterMaterial.opacityTexture = waterTexture;

                // 设置纹理重复和滚动属性
                const textureScale = length * 1.5;
                waterMaterial.diffuseTexture.vScale = textureScale; // V方向缩放
                waterMaterial.diffuseTexture.uScale = 1;            // U方向保持正常
                waterMaterial.diffuseTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE; // 启用重复

                // 关键修改：添加纹理偏移属性以支持动画
                pipe.waterTexture = waterTexture; // 将纹理附加到网格上便于访问
                pipe.flowSpeed = 0.003;           // 水流速度控制因子

                pipe.material = waterMaterial;

                return {
                    mesh: pipe,
                    material: waterMaterial,
                    texture: waterTexture,   // 返回纹理引用
                    length: length,          // 返回管道长度
                    flowSpeed: 0.003         // 默认流动速度
                };
            }

            // 创建水管数组
            const pipes = [
                createPipe(new BABYLON.Vector3(-39.50, 6.22, -29.894), new BABYLON.Vector3(Math.PI / 2, 0, Math.PI / 2), 4.5, 0.4),
                createPipe(new BABYLON.Vector3(-39.50, 6.22, -26.894), new BABYLON.Vector3(Math.PI / 2, 0, Math.PI / 2), 4.5, 0.4),
                createPipe(new BABYLON.Vector3(-39.50, 6.22, -28.394), new BABYLON.Vector3(Math.PI / 2, 0, Math.PI / 2), 4.5, 0.4),
                createPipe(new BABYLON.Vector3(-36.821, 0, -29.894), new BABYLON.Vector3(0, 0, 0), 11.5, 0.4),
                createPipe(new BABYLON.Vector3(-36.821, 0, -26.894), new BABYLON.Vector3(0, 0, 0), 11.5, 0.4),
                createPipe(new BABYLON.Vector3(-36.821, 0, -28.394), new BABYLON.Vector3(0, 0, 0), 11.5, 0.4),
                createPipe(new BABYLON.Vector3(-41.7848, 6.2246, -30), new BABYLON.Vector3(Math.PI / -2, 0, 0), 6, 0.55),
                // 可以添加更多管道...
            ];

            // 水流动画逻辑 - 每帧更新纹理偏移
            scene.registerBeforeRender(() => {
                const deltaTime = scene.getEngine().getDeltaTime() / 1000; // 转换为秒

                pipes.forEach(pipeObj => {
                    // 根据管道长度和速度因子计算当前帧偏移量
                    const speedFactor = pipeObj.flowSpeed * (pipeObj.length / -15);
                    const offsetDelta = speedFactor * deltaTime;

                    // 更新纹理的V偏移（垂直方向）
                    pipeObj.texture.vOffset += offsetDelta;

                    // 防止偏移值过大导致精度问题
                    if (pipeObj.texture.vOffset > 1.0) {
                        pipeObj.texture.vOffset -= 1.0;
                    }
                });
            });

            // 使用示例：调整特定管道流速
            pipes[0].flowSpeed = 3.5;
            pipes[1].flowSpeed = 3.5;
            pipes[2].flowSpeed = 3.5;
            pipes[3].flowSpeed = 3.5;
            pipes[4].flowSpeed = 3.5;
            pipes[5].flowSpeed = 3.5;
            pipes[6].flowSpeed = 3.5;




            setInterval(() => {


                function checkData() {
                    if (window.isDataReady) {


                        if (ok[14] == 1) {
                            console.log(ok); pipes[3].flowSpeed = 1; pipes[4].flowSpeed = 0;
                        }



                    }
                }

                checkData();

            }, 1000);
















            // 获取DOM元素
            const miniMap = document.getElementById("miniMap");
            const cameraDot = document.getElementById("cameraDot");
            const directionArrow = document.getElementById("directionArrow");
            const posXElement = document.getElementById("posX");
            const posYElement = document.getElementById("posY");
            const posZElement = document.getElementById("posZ");
            const angleDegElement = document.getElementById("angleDeg");

            // 地图参数
            const mapSize = 75; // 对应场景大小

            const mapScale = miniMap.offsetWidth / mapSize;

            // 更新小地图位置
            function updateMiniMap() {
                // 计算归一化位置 (0到1范围)
                const normalizedX = (camera1.position.x + mapSize / 2) / mapSize;
                const normalizedZ = (camera1.position.z + mapSize / 2) / mapSize;

                // 计算小地图中的像素位置
                const dotX = normalizedX * miniMap.offsetWidth;
                const dotY = (1 - normalizedZ) * miniMap.offsetHeight;

                // 更新发光点位置
                cameraDot.style.left = dotX + 'px';
                cameraDot.style.top = dotY + 'px';

                // 更新方向箭头
                const forward = camera1.getForwardRay().direction;
                forward.y = 0;
                forward.normalize();
                const angle = Math.atan2(-forward.x, forward.z);
                directionArrow.style.left = dotX + 'px';
                directionArrow.style.top = dotY + 'px';
                directionArrow.style.transform = `translate(-50%, -50%) rotate(${-angle}rad)`;



                // --- 新增：更新坐标和角度显示 ---
                // 显示相机坐标（保留2位小数）
                posXElement.textContent = camera1.position.x.toFixed(2);
                posYElement.textContent = camera1.position.y.toFixed(2);
                posZElement.textContent = camera1.position.z.toFixed(2);

                // 计算并显示角度（转换为度数，0-360°范围）
                let angleDeg = (angle * 180 / Math.PI) % 360;
                if (angleDeg < 0) angleDeg += 360; // 确保角度在0-360之间
                angleDegElement.textContent = angleDeg.toFixed(2) + "°";
            }
















































            // 渲染循环
            engine.runRenderLoop(function () {

                updateMiniMap();
            });

















            return scene;
        };




        // 定义 isRootNode 函数
        function isRootNode(node) {
            return !node.parent;
        }

        window.scene = createScene();
































        engine.runRenderLoop(function () {
            scene.render();

        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
        //BABYLON.Inspector.Show(scene);// 显示调试面板
        //scene.debugLayer.show();

    </script>

    <script> // 故障状态显示
        // 水泵状态显示
        // 独立信号变量
        const pumpSignals3 = {
            names3: ['水泵#1', '水泵#2', '水泵#3', '水泵#4', '水泵#5', '水泵#6'],

            // 状态信号 (0=无, 1=故障)
            status3: ['0', '0', '0', '0', '0', '0'],
            // 水泵启用状态 (0=不显示, 1=显示)
            enabled3: [1, 1, 1, 0, 0, 1] // 初始化为0，后面会根据外部变量更新
        };

        // 外部变量映射到水泵状态
        function updatePumpStatusFromExternalVars3() {
            // 假设外部变量ok3[17]到ok3[22]控制水泵1-6的显示状态
            // 更新启用状态数组
            pumpSignals3.enabled3[0] = ok[17] === '1' ? 1 : 0;

            pumpSignals3.enabled3[1] = ok[18] === '1' ? 1 : 0;
            pumpSignals3.enabled3[2] = ok[19] === '1' ? 1 : 0;
            pumpSignals3.enabled3[3] = ok[20] === '1' ? 1 : 0;
            pumpSignals3.enabled3[4] = ok[21] === '1' ? 1 : 0;
            pumpSignals3.enabled3[5] = ok[22] === '1' ? 1 : 0;


            pumpSignals3.status3[0] = ok[17] || '0';  // 直接使用外部变量
            pumpSignals3.status3[1] = ok[18] || '0';
            pumpSignals3.status3[2] = ok[19] || '0';
            pumpSignals3.status3[3] = ok[20] || '0';
            pumpSignals3.status3[4] = ok[21] || '0';
            pumpSignals3.status3[5] = ok[22] || '0';




            // 更新UI
            updateAllPumpStatuses3();
        }

        /**
         * 初始化水泵卡片
         */
        function initPumpCards3() {
            const container3 = document.getElementById('pump-container3');
            // 先清空容器
            container3.innerHTML = '';

            for (let i = 1; i <= 6; i++) {
                // 只有当对应enabled3为1时才创建卡片
                if (pumpSignals3.enabled3[i - 1] === 1) {
                    const card3 = document.createElement('div');
                    card3.className = 'pump-card3';
                    card3.id = `pump-card3-${i}`;

                    card3.innerHTML = `
                    <div class="card-header3">
                        <i class="fas fa-tint pump-icon3"></i>
                        <div class="card-title3">${pumpSignals3.names3[i - 1]}</div>  <!-- 使用自定义名称 -->
                    </div>
                   
                    <div class="status-indicator3" id="pump3${i}-status3">
                        ${pumpSignals3.status3[i - 1] === '1' ? '故障' : '无'}
                    </div>
                `;

                    container3.appendChild(card3);
                }
            }
        }

        /**
         * 更新单个水泵显示状态
         * @param {number} pumpId - 水泵ID (1-6)
         */
        function updateSinglePumpStatus3(pumpId) {
            // 检查该水泵是否启用
            if (pumpSignals3.enabled3[pumpId - 1] !== 1) return;



            // 更新运行状态显示
            const status3 = pumpSignals3.status3[pumpId - 1];
            const statusElement3 = document.getElementById(`pump3${pumpId}-status3`);

            if (status3 === '1') {
                statusElement3.textContent = '故障';
                statusElement3.className = 'status-indicator3 status-running3';
            } else {
                statusElement3.textContent = '无';
                statusElement3.className = 'status-indicator3 status-stopped3';
            }
        }

        /**
         * 更新所有水泵状态
         */
        function updateAllPumpStatuses3() {
            // 先重新初始化卡片，以防启用状态有变化
            initPumpCards3();

            // 更新每个启用水泵的状态
            for (let i = 1; i <= 6; i++) {
                if (pumpSignals3.enabled3[i - 1] === 1) {
                    updateSinglePumpStatus3(i);
                }
            }
        }

        // 页面加载完成后初始化
        window.addEventListener('load', function () {
            // 带3的系统
            initPumpCards3();
            updateAllPumpStatuses3();
            // 调试：打印 enabled3 状态
            //console.log('enabled3:', pumpSignals3.enabled3);
            //setInterval(updatePumpStatusFromExternalVars3, 1000);
            setInterval(function () {
                updatePumpStatusFromExternalVars3();  // 更新状态
                //console.log('enabled3:', pumpSignals3.enabled3);  // 打印日志
            }, 1000);
        });
    </script>




    <script>// 报警表格
        var responseData;
        var parsedData;
        var resultWrapper;
        document.getElementById('inputC').value = 0;
        document.getElementById('inputD').value = 0;
        let deviceId = document.getElementById('inputC').value;
        let devicePassword = document.getElementById('inputD').value;

        // 获取当前日期
        var currentDate = new Date();
        var currentYear = currentDate.getFullYear().toString().padStart(4, '0');
        var currentMonth = (currentDate.getMonth() + 1).toString().padStart(2, '0');
        var currentDay = currentDate.getDate().toString().padStart(2, '0');
        var formattedCurrentDate = currentYear + currentMonth + currentDay;

        // 计算三天前的日期
        currentDate.setDate(currentDate.getDate() - 3);
        var pastYear = currentDate.getFullYear().toString().padStart(4, '0');
        var pastMonth = (currentDate.getMonth() + 1).toString().padStart(2, '0');
        var pastDay = currentDate.getDate().toString().padStart(2, '0');
        var formattedPastDate = pastYear + pastMonth + pastDay;
        console.log(formattedCurrentDate, formattedPastDate);

        // 设置输入框的值
        document.getElementById('inputA').value = formattedPastDate;
        document.getElementById('inputB').value = formattedCurrentDate;

        function formatDateTime(timestamp) {
            timestamp = timestamp.toString();
            const year = timestamp.substring(0, 4);
            const month = timestamp.substring(4, 6);
            const day = timestamp.substring(6, 8);
            const hour = timestamp.substring(8, 10);
            const minute = timestamp.substring(10, 12);
            const second = timestamp.substring(12, 14);
            return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
        }

        function getSessionIdFromLocalStorage() {
            return localStorage.getItem(deviceId) || null;
        }

        async function fetchDeviceData(sessionId) {
            const requestHeaders = new Headers();
            const apiUrl = `http://47.114.53.27:7080/exdata?SID=${sessionId}&OP=A`;
            const textareaElement = document.getElementById('myTextarea');
            const startDateInput = document.getElementById('inputA').value;
            const endDateInput = document.getElementById('inputB').value;
            const requestBody = `${startDateInput}\r\n${endDateInput}\r\n-\r\n3000`;
            dateRangeString = `${startDateInput}-${endDateInput}`;

            const requestOptions = {
                method: "POST",
                headers: requestHeaders,
                body: requestBody,
                redirect: "follow"
            };

            try {
                const response = await fetch(apiUrl, requestOptions);
                if (!response.ok) {
                    throw new Error('Device data network response was not ok');
                }
                const responseText = await response.text();
                localStorage.setItem("deviceResponse", responseText);
                const storedResponse = localStorage.getItem("deviceResponse");
                parsedData = storedResponse.split(/\r?\n/);
                console.log(parsedData);
                responseData = parsedData;

                if ((parsedData[0] == "ERROR") && (parsedData[1] == 8)) {
                    ycdl(deviceId, devicePassword)
                }

                const tableBody = document.getElementById('data-table').getElementsByTagName('tbody')[0];
                tableBody.innerHTML = '';

                for (let i = 2; i < responseData.length; i += 2) {
                    if ((i + 1 < responseData.length) && (responseData.length > 5)) {
                        const dataRow = responseData[i].split(',');
                        const eventDescription = responseData[i + 1];
                        const eventTimestamp = dataRow[1];
                        const formattedEventTime = formatDateTime(eventTimestamp);

                        const tableRow = document.createElement('tr');
                        tableRow.innerHTML = `
                            <td>${dataRow[0]}</td>
                            <td>${formattedEventTime}</td>
                            <td class="status-${dataRow[2]}">${dataRow[2]}</td>
                            <td>${dataRow.slice(3, 5).join(' ')}</td>
                            <td>${eventDescription}</td>
                        `;
                        tableBody.appendChild(tableRow);
                    }
                }
            } catch (error) {
                console.error(error);
                handleApiError(error);
            }
        }

        async function handleApiError(error) {
            console.error("Error occurred:", error);
            if (error.message.includes("SID")) {
                try {
                    const newSessionId = await authenticateDevice();
                    fetchDeviceData(newSessionId);
                } catch (error) {
                    console.error("Failed to re-authenticate:", error);
                }
            } else {
                console.error("Other error:", error);
            }
        }

        document.getElementById('refreshButton').addEventListener('click', function () {
            
            deviceId = document.getElementById('inputC').value;
            devicePassword = document.getElementById('inputD').value;
            fetchDeviceData(getSessionIdFromLocalStorage());
        });

        function filterTable(columnIndex) {
            const filterInput = document.querySelector(`.filter-input[onkeyup="filterTable(${columnIndex})"]`);
            const filterValue = filterInput.value.toLowerCase();
            const dataTable = document.getElementById('data-table');
            const tableRows = dataTable.getElementsByTagName('tr');

            for (let i = 1; i < tableRows.length; i++) {
                const tableCell = tableRows[i].getElementsByTagName('td')[columnIndex];
                if (tableCell) {
                    if (tableCell.textContent.toLowerCase().indexOf(filterValue) > -1) {
                        tableRows[i].style.display = '';
                    } else {
                        tableRows[i].style.display = 'none';
                    }
                }
            }
        }

        function downloadCSV() {
            var dataTable = document.getElementById("data-table"),
                tableRows = dataTable.querySelectorAll("tr"),
                csvData = [];

            tableRows.forEach(function (row) {
                var tableCells = row.querySelectorAll("td, th");
                var rowData = [];
                tableCells.forEach(function (cell) {
                    if (cell.nodeType === 1) {
                        var cellContent = cell.innerText.replace(/"/g, '""');
                        if (cellContent.search(/("|,|\n)/g) >= 0) {
                            cellContent = '"' + cellContent + '"';
                        }
                        rowData.push(cellContent);
                    }
                });
                csvData.push(rowData.join(","));
            });

            var csvContent = csvData.join("\n");
            var csvBlob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

            var downloadLink = document.createElement("a");
            if (downloadLink.download !== undefined) {
                var blobUrl = URL.createObjectURL(csvBlob);
                downloadLink.setAttribute("href", blobUrl);
                downloadLink.setAttribute("download", `${dateRangeString}设备操作及报警记录.csv`);
                downloadLink.style.visibility = 'hidden';
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(blobUrl);
            }
        }

        document.getElementById("downloadButton").addEventListener("click", downloadCSV);
    </script>


</body>

</html>